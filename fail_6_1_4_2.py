#Используя формулы интерполяционного типа, вычислите интеграл. Оцените погрешность.

'''
Формула Симпсона;
Формула Рунге для оценки погрешности;
'''

import math

def simpson(f, a, b, n):
    """Вычисляет интеграл функции f на интервале [a, b] с помощью формулы Симпсона и n узлами.

    Аргументы:
    f -- функция, которую нужно проинтегрировать
    a -- левый конец интервала
    b -- правый конец интервала
    n -- число узлов (должно быть четным)

    Возвращает значение интеграла.
    """
     # Вычисляем шаг
    h = (b - a) / n
    # Вычисляем значения x и f(x) в узлах
    x = [a + i * h for i in range(n+1)]
    fx = [f(x[i]) for i in range(n+1)]
    # Вычисляем сумму по формуле Симпсона
    s = fx[0] + 4 * sum(fx[i] for i in range(1, n, 2)) + 2 * sum(fx[i] for i in range(2, n-1, 2)) + fx[n]
    # Умножаем сумму на h/3 и возвращаем результат
    return h * s / 3

def adaptive_simpson(f, a, b, eps):
    """Вычисляет интеграл функции f на интервале [a, b] с заданной точностью tol с помощью адаптивной формулы Симпсона.
    
    Аргументы:
    f -- функция, которую нужно проинтегрировать
    a -- левый конец интервала
    b -- правый конец интервала
    eps -- заданная точность

    Возвращает значение интеграла с заданной точностью.
    """
    # Начинаем с двух узлов
    n = 2
    # Вычисляем первую оценку интеграла
    I1 = simpson(f, a, b, n)
    while True:
        # Удваиваем число узлов
        n *= 2
        # Вычисляем новую оценку интеграла
        I2 = simpson(f, a, b, n)
        # Если разница между двумя последовательными оценками интеграла меньше заданной точности, возвращаем последнюю оценку
        if abs(I2 - I1) < eps:
            print(f"Число узлов: {n}")
            return I2
        # Иначе используем новую оценку в качестве предыдущей и продолжаем удваивать число узлов
        I1 = I2

def runge(f, a, b):
    """
    Функция для оценки погрешности вычисления интеграла функции f(x)
    методом Симпсона по формуле Рунге
    """

    M = (max(abs(f(x)), 4) for x in [a, (a+b)/2, b])
    h = (b-a)/2
    return (M/90)*(b-a)*h**4

def f(x):
    return (1.0 / (x + math.sin(0.9 * x)))

a = 3.0 # левый предел интегрирования
b = 4.5 # правый предел интегрирования
eps = 1e-3 # требуемая точность
n = 1 # начальное число узлов

I = adaptive_simpson(f, a, b, eps)

print("Приближенное значение интеграла:", I)

eps = runge(f, a, b)
print("Оценка погрешности:", eps)