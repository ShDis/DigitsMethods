#Дана линейная краевая задача
#{ u'' + p(x)*u' + q(x)*u = f(x), x принадлежит [a,b]
#{ alfa*u'(a) + beta*u(a) = uppercaseA
#{ delta*u'(b) + gamma*u(b) = uppercaseB
#
#Решить краевую задачу, используя метод стрельбы для линейной краевой задачи

'''
Для решения данной краевой задачи с использованием метода стельбы, мы можем следовать следующему алгоритму:

1) Инициализировать начальные значения для искомых функций u(x) и u'(x). Для этого введем параметр t, который будет варьироваться от 0 до 1, и определим функции u_t(x) и u'_t(x) как линейные комбинации граничных условий:
u_t(x) = At + B
u'_t(x) = Ct + D
где A, B, C, D - неизвестные коэффициенты, которые будем находить в процессе решения.

2) Задать начальные значения для A и C, например, A = 1 и C = 0.

3) Решить уравнение второго порядка u'' + p(x)*u' + q(x)*u = f(x) с помощью метода конечных разностей. Для этого разобьем отрезок [a, b] на N равномерных интервалов с шагом h = (b - a) / N, где N - достаточно большое число, чтобы получить достаточно точное приближение. Запишем разностную схему для данного уравнения второго порядка:

(u_{i+1} - 2u_i + u_{i-1})/h^2 + p(x_i)(u_{i+1} - u_{i-1})/(2h) + q(x_i)*u_i = f(x_i)

где u_i - приближенное значение функции u(x) на i-ом интервале, x_i = a + i*h - значение x на i-ом интервале.

Применим эту схему для всех i от 1 до N-1, также учитывая граничные условия в точках a и b.

4) Вычислить значения u_t(a) и u'_t(a) для текущего значения параметра t, используя начальные значения A и C:
u_t(a) = At + B
u'_t(a) = Ct + D

5) Решить уравнение первого порядка alfau'(a) + betau(a) = uppercaseA, подставив вместо u(a) и u'(a) значения, полученные на предыдущем шаге.

6) Решить уравнение первого порядка deltau'(b) + gammau(b) = uppercaseB, подставив вместо u(b) и u'(b) значения, полученные на шаге 3.

7) Проверить точность полученных значений. Если они удовлетворяют заданной точности, то вывести значения u(x) и u'(x) на отрезке [a, b] для найденного значения параметра t. Если точность не достигнута, то перейти на следующий шаг, увеличив значение параметра t и повторить шаги 4-6.
'''

def p(x):
    return -(x ** (1/7)) + 1

def q(x):
    return -((x*x*x) ** (1/7))

def f(x):
    return x 

# Функция для решения уравнения второго порядка методом конечных разностей
def solve_second_order_difference_eq(p, q, f, a, b, N):
    h = (b - a) / N
    x = [a + i * h for i in range(N+1)]
    A = [[0] * (N+1) for _ in range(N+1)]
    B = [0] * (N+1)
    for i in range(1, N):
        A[i][i-1] = 1 / h**2 - p(x[i]) / (2 * h)
        A[i][i] = -2 / h**2 + q(x[i])
        A[i][i+1] = 1 / h**2 + p(x[i]) / (2 * h)
        B[i] = f(x[i])
    A[0][0] = 1
    B[0] = 0
    A[N][N] = 1
    B[N] = 0
    u = [0] * (N+1)
    u[1:N] = solve_tridiagonal_system(A[1:N][1:N], B[1:N])
    return x, u

# Функция для решения трехдиагональной системы линейных уравнений
def solve_tridiagonal_system(A, B):
    n = len(A)
    alpha = [0] * n
    beta = [0] * n
    x = [0] * n

    # Прямой ход
    if abs(A[0][0]) > 1e-10:  # Проверка на ноль
        alpha[1] = -A[0][1] / A[0][0]
        beta[1] = B[0] / A[0][0]

    for i in range(1, n-1):
        if abs(A[i][i] + A[i][i-1]*alpha[i]) > 1e-10:  # Проверка на ноль
            alpha[i+1] = -A[i][i+1] / (A[i][i] + A[i][i-1]*alpha[i])
            beta[i+1] = (B[i] - A[i][i-1]*beta[i]) / (A[i][i] + A[i][i-1]*alpha[i])

    # Обратный ход
    if abs(A[-1][-1] + A[-1][-2]*alpha[-1]) > 1e-10:  # Проверка на ноль
        x[-1] = (B[-1] - A[-1][-2]*beta[-1]) / (A[-1][-1] + A[-1][-2]*alpha[-1])

    for i in range(n-2, -1, -1):
        if abs(A[i][i] + A[i][i+1]*alpha[i+1]) > 1e-10:  # Проверка на ноль
            x[i] = alpha[i+1]*x[i+1] + beta[i+1]

    return x

# Функция для решения краевой задачи методом стрельбы
def shooting_method(p, q, f, a, b, alfa, beta, gamma, delta, uppercaseA, uppercaseB, t_start, t_end, t_step, tolerance, max_iterations):
    t = t_start
    while t <= t_end:
        # Решаем уравнение второго порядка с помощью метода конечных разностей
        N = 100 # Число разбиений
        x, u = solve_second_order_difference_eq(p, q, f, a, b, N)

        # Вычисляем производные u'(a) и u'(b)
        u_prime_a = (u[1] - u[0]) / (x[1] - x[0])
        u_prime_b = (u[-1] - u[-2]) / (x[-1] - x[-2])
    
        # Решаем систему уравнений для нахождения значения параметра t
        # при котором выполняются краевые условия
        A = alfa * u_prime_a + beta * u[0] - uppercaseA
        B = delta * u_prime_b + gamma * u[-1] - uppercaseB
        if abs(A) <= tolerance and abs(B) <= tolerance:
            return x, u
        elif A > 0:
            t += t_step
        elif B > 0:
            t -= t_step
        else:
            t += t_step
        max_iterations -= 1
        if max_iterations == 0:
            raise Exception("Метод стельбы не сошелся за максимальное число итераций")
    return None, None

# Исходные данные
a = 1
b = 2
alfa = 0
beta = -6
gamma = 1
delta = 0
uppercaseA = 1
uppercaseB = 1

# Параметры метода стрельбы
t_start = 1
t_end = 2
t_step = 0.001
tolerance = 1e-2
max_iterations = 1000000

# Вызываем функцию метода стрельбы
x, u = shooting_method(p, q, f, a, b, alfa, beta, gamma, delta, uppercaseA, uppercaseB, t_start, t_end, t_step, tolerance, max_iterations)

# Выводим результаты
if x is not None and u is not None:
    print("Решение уравнения:")
    for i in range(len(x)):
        print(f"u({x[i]}) = {u[i]}")
else:
    print("Метод стельбы не сошелся за максимальное число итераций")