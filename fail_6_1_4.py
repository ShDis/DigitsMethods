#Используя формулы интерполяционного типа, вычислите интеграл. Оцените погрешность.

'''
Для вычисления интеграла с помощью формул интерполяционного типа необходимо сначала разбить интервал интегрирования на несколько частей и на каждой части аппроксимировать подынтегральную функцию интерполяционным полиномом. Затем интеграл на каждой части будет вычислен с помощью соответствующей формулы интерполяционного типа, и сумма полученных значений интегралов будет представлять собой приближенное значение интеграла на всем интервале.

Для оценки погрешности можно воспользоваться формулой Пеано-Башлева. Эта формула позволяет оценить погрешность приближенного вычисления интеграла через максимальное значение n-й производной подынтегральной функции на интервале интегрирования и величину разности между концами интервала.

Формула Пеано-Башлева имеет вид:

| I - I* | <= M / (n+1)! * | b - a | ^ (n+1),

где I - точное значение интеграла, I* - приближенное значение интеграла, M - максимальное значение n-й производной подынтегральной функции на интервале [a, b], n - порядок точности формулы интерполяционного типа, и | b - a | - длина интервала интегрирования.

В зависимости от выбранной формулы интерполяционного типа и количества частей, на которые разбивается интервал интегрирования, можно получить различную точность вычисления интеграла и соответствующую погрешность.
'''

import numpy as np

def interp_formula(f, a, b, n, method='midpoint'):
    """Вычисляет интеграл функции f на интервале [a, b] с помощью формулы интерполяционного типа.

    Аргументы:
    f -- подынтегральная функция
    a -- левый конец интервала интегрирования
    b -- правый конец интервала интегрирования
    n -- порядок точности формулы интерполяционного типа (число узлов интерполяции - 1)
    method -- метод формулы интерполяционного типа ('midpoint', 'trapezoid', 'simpson')

    Возвращает:
    res -- приближенное значение интеграла
    """

    # Определяем узлы интерполяции и соответствующие им веса
    if method == 'midpoint':
        x = np.linspace(a + (b-a)/(2*n), b - (b-a)/(2*n), n)
        w = np.full(n, (b-a)/n)
    elif method == 'trapezoid':
        x = np.linspace(a, b, n+1)
        w = np.full(n+1, (b-a)/(2*n))
        w[0] = w[-1] = (b-a)/(4*n)
    elif method == 'simpson':
        x = np.linspace(a + (b-a)/(2*n), b - (b-a)/(2*n), n)
        w = np.full(n, (b-a)/(3*n))
        w[0::2] = 4*(b-a)/(6*n)
        w[1::2] = 2*(b-a)/(6*n)
    else:
        raise ValueError("Неверный метод формулы интерполяционного типа. Доступные методы: 'midpoint', 'trapezoid', 'simpson'.")

    # Вычисляем значение подынтегральной функции в узлах интерполяции
    y = f(x)

    # Вычисляем приближенное значение интеграла
    res = np.dot(w, y)

    return res


def peano_bashlev(f, a, b, n):
    """Оценивает погрешность приближенного вычисления интеграла функции f на интервале [a, b]
    с помощью формулы Пеано-Башлева.

    Аргументы:
    f -- подынтегральная функция
    a -- левый конец интервала интегрирования
    b -- правый конец интервала интегрирования
    n -- порядок точности формулы интерполяционного типа

    Возвращает:
   
